 /*
*本文档是对本次开发项目中遇到的一些新知识新技术的梳理，同时对一些代码的实际功能进行进一步的解释和改善注释
*此外，还对一些觉得有意义的报错进行记录和更正方法举例
*
*本文档记录了每天在开发过程中的进度
*
*本文档也记录了开发过程中根据原项目改进的具体内容和改进思路
*对游戏内僵尸类型、音效和动画展示都进行了更细致的改进
*/

图片、英语等资源在res下
代码基本完善，但是仍然会出错

=============================================================

23.10.14 

更新窗口用到的渲染图片的方法：putimage()函数
1.参数提供了一个坐标（0，0）其实是指要渲染显示的图形距离窗口左边框和上边框的距离，也就是向右的x坐标轴，和向下的y坐标轴。
2.因为背景全铺开所以提供的背景是（0，0），第三个参数是该背景的文件位置。

植物卡牌的数量：枚举表示
1.植物卡牌的数量可以用宏定义#define ZHI_WU_COUNT xxx来表示，但是这样的话我们只能看到植物的数量，如果用枚举来表示的话可以更加明确有那些植物。
2.枚举本身的特性是会给声明的符号名称指定一个值，一般从0开始递增，所以该枚举类型的最后一个枚举常量ZHI_WU_COUNT代表了总的植物卡牌的数量。

游戏交互实际上通过死循环不断读取用户操作，此时会造成页面渲染好的工具栏等闪烁，解决办法：双缓冲
1.死循环结构中使用updateWindow()函数中会导致页面不断刷新，会造成闪烁。
2.解决闪烁则是在updateWindow()函数中添加双缓冲：使用BeginBatchDraw()把页面渲染先保存到内存中，等所有图片都加载好了，再用EndBatchDraw()函数一次性显示到窗口里。

实现游戏交互功能：peekmessage()
1.peekmessage()函数前面的4个参数（1个指向MSG结构的指标、1个视窗代号、2个值指示消息范围）与GetMessage的参数相同。用于判断当前鼠标或者键盘有无输入。
2.不采用getmessage()函数是因为如果当前没有消息就会卡住。

一个调试快捷键：ctr+F5 同时显示窗口和cmd窗口

植物数组：IMAGE* imgZhiWu[ZHI_WU_COUNT][20];
1.IMAGE* imgZhiWu[ZHI_WU_COUNT][20];声明一个ZHI_WU_COUNT*20的二维数组，每个元素都是指向IMAGE的指针。
2.我们先将每个指针都指向0，因为每个植物的帧数不一定有20张，所以当当前植物的帧数图片播放完后的指针会被指向0，当系统发现指针指向0时说明当前植物播放完，循环结束。

memset(指针，要设置的值，内存的长度)函数：将一片内存设置为一个值。

imgZhiWu[i][j] = new IMAGE; 因为IMAGE的底层是C++，所以不应该用C的内存分配方式，应该用C++的分配方式来进行内存分配。

全局变量和静态变量(static)在程序被加载时就已经分配好内存了，默认为0；局部变量运行时从栈空间分配，数值随机

=======================================================

23.10.15

实现动图效果：循环播放图片

getDelay()：
1.GetTickCount()函数获得开机之后到现在的时钟计数currentTime。
2.第一次调用该函数时，lastTime为0，然后加上现在的currentTime；当第二次调用该函数时用当前currentTime-lastTime则获得一个缓冲时间

优化渲染顺序可以决定图层顺序

解决第二次种植植物的时候图片会在之前种植的植物后闪现一下：
1.闪现图片的原因是我们实现放开鼠标之后种植植物功能后，curX和curY的值仍然是之前已经种植的植物的坐标，我们应当在鼠标按下功能处进行鼠标位置的刷新操作，这样就能解决闪现图片的问题。

一个重点：内存池的实现
经典内存池实现过程：
（1）先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象；
（2）每个对象连同一个指向下一个对象的指针一起构成一个内存节点（Memory Node）。各个空闲的内存节点通过指针形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间；
（3）某个内存节点一旦分配出去，从空闲内存节点链表中去除；
（4）一旦释放了某个内存节点的空间，又将该节点重新加入空闲内存节点链表；
（5）如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。

注意，本文涉及到的内存块链表和空闲内存节点链表的插入，为了省去遍历链表查找尾节点，便于操作，新节点的插入均是插入到链表的头部，而非尾部。当然也可以插入到尾部，读者可自行实现。

================================================================

23.10.16

#include <mmsystem.h>//音乐库
#pragma comment(lib,"winmm.lib")
1.这段代码是用于包含Windows音乐库并链接到winmm.lib库的指令。
2.#include <mmsystem.h> 用于包含Windows音乐库的头文件。
  #pragma comment(lib,"winmm.lib") 是一个编译器指令，用于告诉链接器将winmm.lib库文件链接到程序中。
3.这段代码的目的是使用Windows音乐库中的功能，可能会用到其中的函数和数据结构。通过包含头文件和链接库，可以在代码中调用Windows音乐库提供的函数来播放音乐或进行其他音频相关的操作。
需要注意的是，#pragma comment(lib,"winmm.lib") 是针对Windows平台的编译器指令，在其他平台上可能无法使用。如果你的开发环境不是Windows，可以考虑使用适合该平台的音乐库。

=================================================================

23.10.25

进行已经开发的代码的整理和注释完善

（编译器是vs2022）关于报错：Run-Time Check Failure #2 - Stack around the variable 'xxx' was corrupted的解决方式：
1.这个报错字面意思是定义的变量xxx附近的内存被破坏了，一般情况下，第一反应就是堆栈溢出、内存访问越界
2.如果提示中的变量是指针类型变量，则大概率的就是数组访问越界，需要反复检查数组下标访问的合法性
3.如果提示中的变量并不是指针，而是普通局部变量，在检查代码逻辑无误后，此时问题的解决方案如下：
	（1）可以将该局部变量设置为全局变量即可
	（2）可以在“ 项目 ---- 属性 ---- 配置属性 ---- C/C++ ---- 代码生成 ---- 基本运行时检查：”设置为默认值，点击应用，确定后即可
shoot()函数提示line[5]的报错在设为全局变量后得到改正->仍然有错->已解决 但是可能仍然有错

在僵尸数据更新函数中没有使用第二个计数器count2的原因是僵尸动态会显得很卡顿

===========================================================================

23.10.26

整理目前自己改善的代码：
1.僵尸的数据结构仿照植物在原有基础上写了两种僵尸（举旗僵尸、普通僵尸）
2.僵尸的死亡特效更改为和原游戏一样的效果
3.增加了第一只僵尸出场的音效和子弹射中的音效
4.游戏开始的菜单界面对按钮的状态进行了修改：按下为高亮，放开回复
5.僵尸吃植物的动作也仿照僵尸的数据结构写了两种，同时，第一只僵尸死亡后不再更新举旗僵尸

目前遇到的但未解决bug：
1.有时候运行第一只举旗僵尸并不显示
2.收集太阳时太阳回到太阳数的运动很慢
3.两只僵尸并不会吃同一株植物
4.如果有一株植物被僵尸A攻击，当僵尸A死亡后，这株植物仍然存活的状态下，之后出现的僵尸会忽略这株植物
5.如果新僵尸出现在旧僵尸的上一行，那么他的渲染顺序会晚于旧僵尸，出现贴图错误

如果有可能将会在后期改进：
1.添加音效如：种植植物、植物被啃食、僵尸随机的嘶吼、僵尸吃完一株植物的吞咽等音效
2.目前整个游戏背景是显示不完全的，整个背景应该向左移动
3.实现铲子功能或者更多植物、僵尸

==============================================================================

23.10.28

实现了片头巡场：
1.僵尸相对于窗口是移动的，但是相对于背景图片的位置的绝对的，所以我们计算的x可以相对于背景图片计算
2.站立僵尸的位置就是背景图片的最右边一片位置，而我们假设xMin是背景的x坐标，为窗口的宽度-背景宽度，其实就是	900-1398=-498
    而我们已知僵尸最终在窗口里的刷新位置（例如550），那么僵尸的刷新坐标一直为：
	points[k].x - xMin + x
3.下面详细记录这个坐标的变化原理，首先是xMin + x部分，由于xMin是负数，那么这个式子计算出的是僵尸最终的位置跟着背景的偏移量，例如550处的僵尸一开始的位置应该是
	550-（-498+0）=1048
  因为僵尸的刷新语句嵌套在背景的移动循环中，x一直在递减2直到背景图片在窗口到达想要的位置，即x<=-498，此时僵尸的位置也应该跟随移动：
	550-(-498+498)=550
  僵尸逐渐刷新到存在的位置，而切回直接游戏的画面则是僵尸随着背景退出，是上述的反过程

还可以进行的改进：
1.菜单点击开始游戏时的动画